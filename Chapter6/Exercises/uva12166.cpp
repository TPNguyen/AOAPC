// Equilibrium Mobile, NWERC 2008, UVa 12166
// My original thought was that: when returning from a dfs scan, the return value would be a list of pairs:
// (# of changes, vector<int> possible weights). It contains a special pair which include changing all weights, which
// ultimately means that it can match any weight on the other end of the mobile. Then the final step of dfs is to
// merge these two lists (returned from possible two child mobile), sorting according to minimum changes of weights.
// At the root of the tree, it would receive a list of at most 2^16 pairs.
//
// But I found the following algorithm quite clever too:
// http://morris821028.github.io/2014/10/03/oj/uva/uva-12166/
// http://www.cnblogs.com/Emerald/p/4687517.html
// http://blog.csdn.net/crazysillynerd/article/details/43876123
// The idea is that the relationship of weights at neighboring levels are fixed: parent node has twice the weight
// of its child weights. So all possible weights can be generated by iterating over all the leaf weights. This is
// equivalent to my original pairs' second components combined. The next step is quite clever to observe: in order
// to have minimum number of changes, you want the most number of leaf weights untouched which all of them give you
// the same final weight of the mobile.

#include <iostream>
#include <map>
#include <string>
using namespace std;

void print_ans();
void dfs(const string &expr, int dep);

map<long long, int> totw;
string expr;

int main()
{
    ios_base::sync_with_stdio(false);
    int Kase; cin >> Kase;
    while (Kase--)
    {
        cin >> expr;
        totw.clear();
        dfs(expr, 0);
        print_ans();
    }

    return 0;
}

void dfs(const string &expr, int dep)
{
    if (expr[0] != '[') // a leaf weight
    {
        long long int w = stoi(expr.substr(0, expr.find_first_of(',')));
        totw[w<<dep]++;
    }
    else // is a rod, depth++
    {
        int p = 0;
        for (auto i = 1; i < expr.size()-1; ++i)
        {
            if (expr[i] == '[') p++;
            else if (expr[i] == ']') p--;
            else if (p == 0 && expr[i] == ',')
            {
                dfs(expr.substr(1, i-1), dep+1);
                dfs(expr.substr(i+1, expr.size()-i-1), dep+1);
                break;
            }
        }
    }
}

void print_ans()
{
    int max_num = 0;
    int total = 0;
    for (const auto& p: totw)
    {
        total += p.second;
        if (p.second > max_num)
            max_num = p.second;
    }

    cout << total-max_num << "\n";
}



